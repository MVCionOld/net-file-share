# Задание на кафедру 2019


### Условие

Необходимо реализовать консольную программу, которая позволяет переслать файл с одного компьютера на другой. Особенность в том, что один ПК работает под управлением Linux, другой - под управлением Windows. Дополнительной особенностью также должно являться то, что файл передается по частям в несколько потоков параллельно. Все аргументы передаются через аргументы консоли. Аргументы именованные, порядок аргументов любой.

Варианты использования:  
`program --receive` - запускает программу в режиме готовности принять файл  
`program --send --ip <IP> --file <FILENAME> --threads <THREAD>` - запускает программу в
режиме передачи файла  
где `<IP>` - IP-адрес принимающей машины, `<FILENAME>` - имя передаваемого файла (либо имя и файл лежит “рядом” с программой, либо абсолютный путь к файлу), `<THREAD>` - число потоков для передачи. Нельзя использовать готовые библиотеки, реализующие нужные функции. Можно использовать системные библиотеки для прямой работы с сокетами.

Пример использования:
* ПК1: `program --receive`
* ПК2: `program --send --ip 192.154.3.14 --file arch.zip --threads 5`

В итоге на ПК1 в директории, где расположен файл программы, должна появиться копия `arch.zip`, передача должна была быть осуществлена в 5 потоков.

### Реализация

За основу была взята классическая **клиент-серверная ахитектура**, где клиентом есть компьютер, отправляющий файл, а сервером - принимающая сторона (далее, **клиент** - ```C```, **сервер** - ```S```).   
Изначально ```C``` не знает номер нужного порта ```S```, поэтому воспроизводит опрос портов в диапазоне с ```PortRange::FROM (=59060)``` по ```PortRange::TO (=60084)``` по заданному ```<IP>```. При удачном подключении, ```C``` генерирует рандомную строку длиной 64 байта, отправляет на сервер и ожидает в ответ эту же строку. После происходит настройка передачи данных:
1. ```C``` отправляет ```S``` количество потоков, которое хочет использовать при передаче, имя файла и его размер  
2. ```S``` открывает нужное количество портов (или доступное кол-во, в том же диапазоне: ```59060..60084```)
3. ```S``` создает по потоку для каждого порта на ```accept```
4. ответ приходит к ```C``` в виде кол-ва портов и их номеров.

```C``` присоединяется к открытым портам, ```C``` и ```S``` синхронизируются, после начинается многопоточная передача файла.

### Ограничения

* Количество потоков программно ограничено до **128** потоков
* За раз поток может отправить на сервер пакет размером не более **1Кб** данных

### Дополнительно 

Возможность использовать знаки равно ```=``` и однобуквеннные алиасы для аргументов командной строки, к примеру, следующие запуски эквивалентны:
* ```program --send --ip 192.154.3.14 --file arch.zip --threads 5```
* ```program -s -i 192.154.3.14 -f arch.zip -t 5```
* ```program --send --ip=192.154.3.14 --file=arch.zip --threads=5```
* ```program -s -i=192.154.3.14 -f=arch.zip -t=5```

Можно передавать файлы более **4Гб**.

Полная совместимость реализации под ```Linux``` c ```MacOS```.

Для реализации под ```Windows``` используется ```WinApi```.

Для низкоуровневых системных вызовов сделаны специальные обертки, которые освобождают от необходимости писать платформозависимый код в высокоуровневом. Вопрос платформозависимости решен путем использования макросоподстановок ```include'ов``` в ```./sender/CSender.hpp``` и ```./receiver/CReceiver.hpp```.

### Степень готовности

Полностью готово всё, кроме реализации под Windows - найдены баги (ошибки исполнения и линковки?), но дедлайн прошел, первый и последний коммит после него - это единственный README.

### P.S.

Спасибо [Дмитрию Родионову](https://github.com/lhjlbjyjd) за то, что разрешил потестить на своем MAC'e.
